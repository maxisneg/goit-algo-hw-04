 Порівняння швидкості алгоритмів сортування

Це дослідження порівнює час роботи трьох алгоритмів сортування:
 Сортування вставками (Insertion Sort)
  Сортування злиттям (Merge Sort)
Timsort (вбудований алгоритм Python)

Тестування проводилося на різних наборах даних (випадкові, відсортовані, зворотно відсортовані тощо) та різних розмірах масивів.

 Результати тестування

# Емпіричні результати тестування (час у секундах)

Випадкові дані
| Розмір масиву | Insertion Sort | Merge Sort | Timsort (Python's sort) |
|------------|---------------|----------|------------------|
| 100          | 0.000041       | 0.000106   | 0.000003                |
| 1000         | 0.003734       | 0.001368   | 0.000064                |
| 5000         | 0.100837       | 0.008156   | 0.000639                |

### Відсортовані дані
| Розмір масиву | Insertion Sort | Merge Sort | Timsort (Python's sort) |
|------------|---------------|----------|------------------|
| 100          | 0.000007       | 0.000109   | 0.000001                |
| 1000         | 0.000103       | 0.001440   | 0.000007                |
| 5000         | 0.000458       | 0.007712   | 0.000029                |

### Зворотно відсортовані дані
| Розмір масиву | Insertion Sort | Merge Sort | Timsort (Python's sort) |
|------------|---------------|----------|------------------|
| 100          | 0.000089       | 0.000092   | 0.000001                |
| 1000         | 0.006732       | 0.001200   | 0.000006                |
| 5000         | 0.185159       | 0.008262   | 0.000034                |

### Майже відсортовані дані
| Розмір масиву | Insertion Sort | Merge Sort | Timsort (Python's sort) |
|------------|---------------|----------|------------------|
| 100          | 0.000012       | 0.000100   | 0.000003                |
| 1000         | 0.000568       | 0.001467   | 0.000028                |
| 5000         | 0.013405       | 0.007820   | 0.000180                |

### Дані з дублікатами
| Розмір масиву | Insertion Sort | Merge Sort | Timsort (Python's sort) |
|------------|---------------|----------|------------------|
| 100          | 0.000033       | 0.000101   | 0.000002                |
| 1000         | 0.004226       | 0.001479   | 0.000059                |
| 5000         | 0.096688       | 0.009794   | 0.000508                |

 Основні висновки

1.  Timsort демонструє найкращу загальну продуктивність, особливо ефективний на частково впорядкованих даних.
2.  Сортування злиттям показує стабільні $O(n \log n)$ результати.
3.  Сортування вставками ефективне для дуже малих масивів або майже відсортованих даних, але значно повільніше на великих невпорядкованих масивах ($O(n^2)$).

 Для більшості завдань у Python найкраще використовувати вбудовані методи сортування (`list.sort()` або `sorted()`), які реалізують Timsort.



 Необов'язкове завдання

Реалізовано функцію `merge_k_lists` для об'єднання `k` відсортованих списків в один.

